%======================
\chapter{Les tableaux}
%======================

	\marginicon{objectif}
	Dans ce chapitre nous étudions les tableaux, 
	une structure qui peut contenir 
	plusieurs exemplaires de données similaires.

	% =============================
	\section{Utilité des tableaux}
	% =============================
	
		Nous allons introduire la notion de tableau à partir d’un exemple 
		dans lequel l’utilité de cette structure de données 
		apparaitra de façon naturelle.
	
		\textbf{Exemple.}
		Statistisques de ventes.
		\begin{quote}	
			Un gérant d’une entreprise commerciale 
			souhaite connaitre l’impact 
			d’une journée de promotion publicitaire 
			sur la vente de dix de ses produits.
			Pour ce faire, les numéros de ces produits 
			(numérotés de 0 à 9 pour simplifier) 
			ainsi que les quantités vendues 
			pendant cette journée de promotion 
			sont encodés au fur et à mesure de leurs ventes. 
			En fin de journée, 
			le vendeur entrera la valeur -1 
			pour signaler la fin de l’introduction des données. 
			Ensuite, les statistiques des ventes seront affichées.
		\end{quote}
	
		La démarche générale se décompose en trois parties~:
		\begin{itemize}
		\item
			le traitement de début de journée, qui consiste essentiellement à mettre
			les compteurs des quantités vendues pour chaque produit à 0
		\item
			le traitement itératif durant toute la journée~: 
			au fur et à mesure des ventes, 
			il convient de les enregistrer, 
			c’est-à-dire d’ajouter au compteur des ventes d’un produit 
			la quantité vendue de ce produit ; 
			ce traitement itératif s’interrompra lorsque la valeur 0 sera introduite
		\item
			le traitement final, consistant à communiquer les valeurs des compteurs
			pour chaque produit.
		\end{itemize}
	
		Vous trouverez sur la page suivante
		une version possible de cet algorithme.
	
		\begin{LDA}
		\LComment Calcule et affiche la quantité vendue de 10 produits.
		\Algo{statistiquesVentesSansTableau}{}{}
			\Empty
			\Decl{cpt0,cpt1, cpt2, cpt3, cpt4, cpt5, cpt6, cpt7, cpt8, cpt9}{entiers}
			\Decl{numéroProduit, quantité}{entiers}
			\Empty
			\Let cpt0 \Gets 0
			\Let cpt1 \Gets 0
			\Let cpt2 \Gets 0
			\Let cpt3 \Gets 0
			\Let cpt4 \Gets 0
			\Let cpt5 \Gets 0
			\Let cpt6 \Gets 0
			\Let cpt7 \Gets 0
			\Let cpt8 \Gets 0
			\Let cpt9 \Gets 0
			\Empty
			\Write "Introduisez le numéro du produit~:"
			\Read numéroProduit
			\Empty
			\While{numéroProduit $\neq$ -1}
			\Empty
				\Write "Introduisez la quantité vendue~:"
				\Read quantité
				\Empty
				\Switch{numéroProduit \K{vaut}}
					\Stmt 0~: cpt1 \Gets cpt10 + quantité
					\Stmt 1~: cpt1 \Gets cpt1 + quantité
					\Stmt 2~: cpt2 \Gets cpt2 + quantité
					\Stmt 3~: cpt3 \Gets cpt3 + quantité
					\Stmt 4~: cpt4 \Gets cpt4 + quantité
					\Stmt 5~: cpt5 \Gets cpt5 + quantité
					\Stmt 6~: cpt6 \Gets cpt6 + quantité
					\Stmt 7~: cpt7 \Gets cpt7 + quantité
					\Stmt 8~: cpt8 \Gets cpt8 + quantité
					\Stmt 9~: cpt9 \Gets cpt9 + quantité
				\EndSwitch
				\Empty
				\Write "Introduisez le numéro du produit~:"
				\Read numéroProduit
				\Empty
			\EndWhile
			\Empty
			\Write "quantité vendue de produit 0~:", cpt0
			\Write "quantité vendue de produit 1~:", cpt1
			\Write "quantité vendue de produit 2~:", cpt2
			\Write "quantité vendue de produit 3~:", cpt3
			\Write "quantité vendue de produit 4~:", cpt4
			\Write "quantité vendue de produit 5~:", cpt5
			\Write "quantité vendue de produit 6~:", cpt6
			\Write "quantité vendue de produit 7~:", cpt7
			\Write "quantité vendue de produit 8~:", cpt8
			\Write "quantité vendue de produit 9~:", cpt9
			\Empty
		\EndAlgo
		\end{LDA}
	
		Il est clair, à la lecture de cet algorithme, 
		qu’une simplification d’écriture s’impose ! 
		Et que ce passerait-il si le nombre de produits à
		traiter était de 20 ou 100 ? 
		Le but de l’informatique étant de dispenser l’humain 
		des tâches répétitives, 
		le programmeur peut en espérer autant 
		de la part d’un langage de programmation !
		La solution est apportée par un nouveau type de variables~: 
		les \textbf{variables indicées} ou \textbf{tableaux}.
	
		Au lieu d’avoir à manier dix compteurs distincts
		(\lda{cpt0}, \lda{cpt21}, etc.), 
		nous allons envisager une seule «~grande~» variable 
		\lda{cpt} compartimentée en dix «~sous-variables~» 
		qui se distingueront les unes des autres par un indice~: 
		\lda{cpt0} deviendrait ainsi \lda{cpt[1]}, 
		\lda{cpt1} deviendrait \lda{cpt[1]}, 
		et ainsi de suite jusqu’à
		\lda{cpt9} qui deviendrait \lda{cpt[9]}.
	
		\begin{center}
			\begin{tabular}{*{11}{>{\centering\arraybackslash}m{7mm}}}
				{} &
				\lda{cpt[0]} &
				\lda{cpt[1]} &
				\lda{cpt[2]} &
				\lda{cpt[3]} &
				\lda{cpt[4]} &
				\lda{cpt[5]} &
				\lda{cpt[6]} &
				\lda{cpt[7]} &
				\lda{cpt[8]} &
				\lda{cpt[9]} 
				\\\hhline{~*{10}{-}}
				\multicolumn{1}{m{7mm}|}{\lda{cpt}} &
				\multicolumn{1}{m{7mm}|}{~} &
				\multicolumn{1}{m{7mm}|}{~} &
				\multicolumn{1}{m{7mm}|}{~} &
				\multicolumn{1}{m{7mm}|}{~} &
				\multicolumn{1}{m{7mm}|}{~} &
				\multicolumn{1}{m{7mm}|}{~} &
				\multicolumn{1}{m{7mm}|}{~} &
				\multicolumn{1}{m{7mm}|}{~} &
				\multicolumn{1}{m{7mm}|}{~} &
				\multicolumn{1}{m{7mm}|}{~}
				\\\hhline{~*{10}{-}}
			\end{tabular}
		\end{center}
	
		Un des intérêts de cette notation 
		est la possibilité de faire apparaitre
		une variable entre les crochets, 
		par exemple \lda{cpt[i]}, 
		ce qui permet une grande économie de lignes de code.
		
		Voici la version avec tableau.
	
		\label{tableau:tab1DStock10Articles}
		\begin{LDA}
		\label{tableau:tab1DStock10Articles}
		\LComment Calcule et affiche la quantité vendue de 10 produits.
		\Algo{statistiquesVentesAvecTableau}{}{}
			\Empty
			\Decl{cpt}{\Array{10}{entiers}}
			\Decl{i, numéroProduit, quantité}{entiers}
			\Empty
			\For{i}{1}{10}{}
				\Let cpt[i] \Gets 0
			\EndFor
			\Empty
			\Write "Introduisez le numéro du produit~:"
			\Read numéroProduit
			\Empty
			\While{numéroProduit $\neq$ -1}
			\Empty
				\Write "Introduisez la quantité vendue~:"
				\Read quantité
				\Empty
				\Let cpt[numéroProduit] \Gets cpt[numéroProduit] + quantité
				\Empty
				\Write "Introduisez le numéro du produit~:"
				\Read numéroProduit
				\Empty
			\EndWhile
			\Empty
			\For{i}{1}{10}{}
				\Write "quantité vendue de produit ", i, ": ", cpt[i]
			\EndFor
			\Empty
		\EndAlgo
		\end{LDA}
		
	% ====================
	\section{Définitions}
	% ====================
	
		\marginicon{definition}
		Un \textbf{tableau} est une suite d’éléments de même type 
		portant tous le même nom mais se distinguant 
		les uns des autres par un indice.
	
		L’\textbf{indice} est un entier 
		donnant la position d’un élément dans la suite. 
		Cet indice varie entre la position du premier élément 
		et la position du dernier élément, 
		ces positions correspondant aux bornes de l’indice.
		Notons qu'il n'y a pas de «~trou~»~: 
		tous les éléments existent entre le premier et le dernier indice.
	
		\marginicon{definition}
		La \textbf{taille} d’un tableau 
		est le nombre (strictement positif) de ses éléments.
		Attention ! la taille d’un tableau ne peut pas être modifiée pendant
		son utilisation.
	
	% ==================
	\section{Notations}
	% ==================
	
		\marginicon{definition}
		Pour déclarer un tableau, on écrit~:
	
		\begin{LDA}
		\Decl{nomTableau}{\Array{taille}{TypeElément}}
		\end{LDA}
		
		où \lda{TypeElément} est le type des éléments 
		que l’on trouvera dans le tableau.
		Tous les types sont permis. 
	
		Une fois un tableau déclaré, 
		seuls les éléments d’indice compris entre
		0 et taille-1 peuvent être utilisés. 
		Par exemple, si on déclare~:
	
		\begin{LDA}
		\Decl{tabEntiers}{\Array{100}{entiers}}
		\end{LDA}
		
		il est interdit d’utiliser \lda{tabEntiers[-1]} ou
		\lda{tabEntiers[100]}. 
		De plus, chaque élément
		\lda{tabEntiers[i]} (avec $0 \leq i < 100$) 
		doit être manié avec la même précaution 
		qu’une variable simple, 
		c’est-à-dire qu’on ne peut utiliser un élément du tableau 
		qui n’aurait pas été préalablement affecté ou initialisé.
	
		N.B.~: Nous considérons que la première case du tableau
		porte le numéro 0 comme c'est le cas dans beaucoup de langage
		de programmation (comme Java par exemple).
		Plus loin, nous verrons une notation alternative
		qui permet de choisir un autre numéro de début pour le tableau
		ce qui sera plus naturel pour certains problèmes.
	
	% ==============================================
	\section{Parcours d'un tableau à une dimension} 
	\label{Les parcours de tableaux}
	% ==============================================
	
		Dans la plupart des problèmes que vous rencontrerez
		vous serez amener à parcourir le tableau 
		dans sa totalité ou en partie.
		Il est important de maitriser ce parcours.
		Examinons les situations courantes 
		et voyons quelles solutions conviennent.
		
		Soit le tableau \lda{tab} déclaré ainsi
		
		\begin{LDA}
			\Decl{tab}{\Array{n}{entiers}} \RComment où un autre type
		\end{LDA}
		
		Envisageons d'abord le parcours complet
		et voyons ensuite les parcours avec arrêt prématuré.
	
		\subsection{Parcours complet}
		
			Pour parcourir complètement un tableau, 
			on peut utiliser la boucle \K{pour}.
			Dans l'algorithme suivant,
			on affiche tous les élements du tableau 
			mais on pourrait faire autre chose avec ces éléments :
			les sommer, les comparer\dots

			\begin{LDA}
				\LComment{Parcours complet d'un tableau via une boucle pour}
				\For{i}{0}{n-1}{}
					\Write tab[i]
				\EndFor
			\end{LDA}
		
		\subsection{Parcours avec sortie prématurée}
		
			Parfois, on ne doit pas forcément parcourir 
			le tableau jusqu'au bout
			mais on pourra s'arrêter prématurément 
			si une certaine condition est remplie.
			Par exemple~:
			\begin{itemize}
			\item on cherche la présence d'un élément et on vient de le trouver ;
			\item on vérifie qu'il n'y a pas de $0$ et on vient d'en trouver un.
			\end{itemize}
			
			La première étape est de transformer le \K{pour} en \K{tant que}
			ce qui donne l'algorithme 
			
			\begin{LDA}
				\LComment{Parcours complet d'un tableau via une boucle tant-que}
				\Decl{i}{entier}
				\Let i \Gets 0
				\While{i < n}
					\Write tab[i]
					\Let i \Gets i + 1
				\EndWhile
			\end{LDA}
			
			On peut à présent introduire le test d'arrêt.
			Une contrainte est qu'on voudra, à la fin de la boucle, 
			savoir si oui ou non on s'est arrêté prématurément et, 
			si c'est le cas, à quel indice.
			
			Il existe essentiellement deux solutions, avec ou sans variable booléenne.
			En général, la solution [A] sera plus claire si le test est court.
		
			\subsubsection*{[A] Sans variable booléenne}
			
				\begin{LDA}
					\LComment{Parcours partiel d'un tableau sans variable booléenne}
					\Decl{i}{entier}
					\Let i \Gets 0
					\While{i < n ET \textit{test sur tab[i] dit que on continue}}
						\Let i \Gets i + 1
					\EndWhile
					\If{i = n}
						\LComment on est arrivé au bout
					\Else
						\LComment arrêt prématuré à l'indice i.
					\EndIf
				\end{LDA}
			
				Il faut être attentif à \textbf{ne pas inverser}
				les deux parties du test.
				Il faut absolument vérifier que l'indice est bon avant
				de tester la valeur à cet indice.
				
				On pourrait inverser les deux branches 
				du \K{si-sinon} en inversant le test
				mais attention à ne pas tester tab[i] 
				car $i$ n'est peut-être pas valide.
			
				Dans certains cas, le \K{si-sinon} peut se simplifier
				en un simple \K{return} d'une condition.
				
				\textbf{Exemple} : Recherche d'un zéro dans un tableau.
			
				\begin{LDA}
					\LComment{Indique si un zéro est présent dans le tableau}
					\Algo{contientZéro}{\Par{tab}{\Array{n}{entiers}}}{booléen}
					\Decl{i}{entier}
					\Let i \Gets 0
					\While{i < n ET tab[i] $\neq$ 0}
						\Let i \Gets i + 1
					\EndWhile
					\Return {i < n} \RComment{Si le test est vrai c'est qu'on a trouvé un 0}
					\EndAlgo
				\end{LDA}
				
			\subsubsection*{[B] Avec variable booléenne}
			
				\begin{LDA}
					\LComment{Parcours partiel d'un tableau avec variable booléenne}
					\Decl{i}{entier}
					\Decl{trouvé}{booléen}
					\Let i \Gets 0
					\Let trouvé \Gets faux
					\While{i < n ET NON trouvé}
						\If{\textit{test sur tab[i] dit que on a trouvé}}
							\Let trouvé \Gets vrai
						\Else
							\Let i \Gets i + 1
						\EndIf
					\EndWhile
					\LComment tester le booléen pour savoir si arrêt prématuré.
				\end{LDA}
				
				Attention à bien choisir un nom de booléen 
				adapté au problème
				et à l'initialiser à la bonne valeur. 
				Par exemple, si la variable s'appelle \og{}continue\fg{}
				\begin{itemize}
				\item initialiser la variable à vrai ;
				\item le test de la boucle est \og\lda{\dots ET continue}\fg{} ;
				\item mettre la variable à faux pour sortir de la boucle.
				\end{itemize}
		
	
